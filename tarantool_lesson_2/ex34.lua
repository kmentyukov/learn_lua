-- В спейсе с одним полем uuid можно хранить стековые данные, в виде дополнительных полей кортежа. То есть, каждая запись в спейсе представляет 
-- собой отдельный стек с его данными.
-- Определить следующие функции:
--   stack_new(id) - создаёт запись в спейсе со строковым идентификатором <id>.
--   stack_push(id, data) - принимает первым аргументом идентификатор стека, вторым аргументом данные, которые нужно положить в стек. 
--     Возвращает true, если удалось положить данные в стек, или false, если в стек больше данные не получится положить. Размещение нового 
--     элемента расширяет кортеж (добавляет поле). 
--   stack_pop(id) - принимает первым аргументов идентификатор стека, снимает значение с вершины 
--     стека и возвращает его. Удаление элемента урезает кортеж (удаляет поле).
--   stack_delete(id) - удаляет стек из спейса.
-- Для функций stack_push и stack_pop предложить несколько вариантов реализации и измерить их их производительность.
-- Сколько данных можно положить в стек и от какого параметра это зависит?
-- Будет ли работать создание, изменение и удаление стеков, если в параметрах спейса задан параметр field_count? Созданная схема данных 
--   предполагает, что данные, размещаемые на стеке, могут быть любого типа. Какие проблемы могут возникнуть, если проверять через функцию 
--   type? Как можно ограничить тип данных с помощь схемы? Например, нужно указать, что в стек должны добавляться только числа типа unsigned.
-- Добавить поле со временем последнего изменения содержимого стека и обновлять его при каждой операции. Добавить поле с номером версии. 
--   Добавить в каждый метод (кроме dict_new) аргумент "номер версии" и обновлять только тогда, когда номера версий совпадают. Каждая операция 
--   увеличивает номер версии на 1.

box.cfg{
    listen = 3301,
    work_dir = 'data'
}

box.schema.space.create('stacks', {
    if_not_exists = true,
    format = {
        {'id', 'string'}
    },
    engine = 'memtx'
})

box.space.stacks:create_index('pk', {if_not_exists = true})

local function stack_new(id)
    box.space.stacks:insert({tostring(id)})
end

local function stack_push(id, data)
    local res = box.space.stacks:update(tostring(id), {{'!', 2, data}})
    if res == nil then
        return false
    end
    return true
end

local function stack_pop(id)
    local res = box.space.stacks:get(tostring(id))[2]
    box.space.stacks:update(tostring(id), {{'#', 2, 1}})
    return res
end

local function stack_delete(id)
    box.space.stacks:delete(tostring(id))
end

-- Количество данных в кортеже ограничено параметром memtx_max_tuple_size, по умолчанию 1048576 байт.
-- Количество полей в кортеже не ограничено по умолчанию. Чтобы ограничить количество полей, необходимо указать для спейса элемент field_count. 
-- Создание, изменение и удаление стеков, если в параметрах спейса задан параметр field_count. Нельзя добавить полей больше, чем указано в этом
--   параметре (меньше можно).
-- Типы полей, указанных в схеме и типы данных в Lua могут различаться. Например поле с ворматом datatime, а проверка через type вернет cdata
-- Можно задать тип для второго поля в кортеже и затем вставлять новые данные только на вторую позицию. Предыдущие будут сдвигаться на 3 позицию 
--   и далее.



-- У меня это задание съело какое-то огромное количество времени в связи с поиском информации. Для удобства ответов на вопросы лучше один вопрос - 
-- один ответ. Задание лучше разделить на два, т.к. послдений вопрос непонятно как оформлять.
